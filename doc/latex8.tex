
%
%  $Description: Author guidelines and sample document in LaTeX 2.09$ 
%
%  $Author: ienne $
%  $Date: 1995/09/15 15:20:59 $
%  $Revision: 1.4 $
%

\documentclass[times, 10pt,twocolumn]{article} 
\usepackage{latex8}
\usepackage{times}
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage{enumitem}
\usepackage[font=small]{caption}

%\documentstyle[times,art10,twocolumn,latex8]{article}

%------------------------------------------------------------------------- 
% take the % away on next line to produce the final camera-ready version 
\pagestyle{empty}

%------------------------------------------------------------------------- 
\begin{document}

\title{Distributed Software Transactional Memory}

\maketitle
\thispagestyle{empty}

\begin{abstract}


   The present paper describes the details of a distributed software
   transactional memory implementation.
   There are 2 scenarios presented for a Master/Server architecture: \\
   a) perfect links and processes (Master and Servers) \\
   b) perfect links and Master, but recoverable Servers \\

   Transaction management, concurrency control, failure detector and 
   replication mechanisms are described for both perfect and fault-tolerant
   architectures.
   
\end{abstract}



%------------------------------------------------------------------------- 
\Section{Introduction}
In the following sections the implementation of a distributed software 
transactional memory library is presented for two scenarios:\\
a) perfect Master, Servers and links\\
b) perfect Master, links and recoverable, sequentially consistent Servers\\

Section \ref{sec:arch} introduces an overview of each scenario. Section 
\ref{sec:algor} discusses the algorithms used for concurrency control, 
transaction management and Client-Server communication


%------------------------------------------------------------------------- 
\Section{Architecture}
\label{sec:arch}

The assumption made for all the sections below is that the Master is a perfect process. The names Object Servers and Servers are used interchangeably across the sections below and refer to the any non-Master process participant in a transaction.

Main differences between the two architectures, perfect and fault-tolerant, are the following:
\begin{itemize}[noitemsep,nolistsep]
\item for perfect, the Coordinator can be any server, not necessarily the Master
\item 
\end{itemize}
%TODO: Add more differences between the two archs.

%------------------------------------------------------------------------- 
\SubSection{Perfect links and processes}
\label{subsec:perf}
As illustrated in Figure \ref{fig:perf}, the architecture consists of the 
following entities: 
\begin{itemize}[noitemsep,nolistsep]
\item {\bf M} - Master server 
\item {\bf S} - Object server
\item {\bf C} - Client      
\end{itemize}

\begin{figure}
\centering
\includegraphics[scale=0.3]{perfect.eps}
\caption{Master/Server entities in a perfect setup}
\label{fig:perf}
\end{figure}
Note that the number of object servers can be varied.
%------------------------------------------------------------------------- 
\SubSection{Recoverable, replicated Servers with perfect Master}
\label{subsec:recov}

%------------------------------------------------------------------------- 
\SubSection{Coordinator/Master responsiblities}
\label{subsec:respon}

The Coordinator's responsabilities and interface are different for the two scenarios (perfect and fault-tolerant) detailed in Section \ref{sec:arch}. For instance, assuming perfect links and processes, the Coordinator can be any of the Servers, thus reducing the Master's load. The list of servers available to the Client is supplied by the Master and it's updated with every Server group membership change.

The responsibilities below are shared for both scenarios:
\begin{itemize}[noitemsep,nolistsep]
\item {\bf M} - Master server 
\item {\bf S} - Object server
\item {\bf C} - Client      
\end{itemize}

%------------------------------------------------------------------------- 
\Section{Algorithms}
\label{sec:algor}
In the subsections below, algorithms for communication, concurrency, deadlock detection and transaction management are enlisted.

%------------------------------------------------------------------------ 
\SubSection{Communication}
The following communication occurs {\bf before} the Client attempts connection to the Master node - between the Master and the Servers.

\begin{enumerate}
\item Master boots, followed by the Object Servers bootstrapping
\item During Object Servers bootstrap:
\begin{itemize}[noitemsep, nolistsep]
\item Master identifies the Object Servers trying to connect
\item Master assigns a unique name to the Object Servers to later be used as a reference
\end{itemize}
\item Object Servers's heartbeat messages periodically being sent to Master. Heartbeats are also used for replica management in the faul-tolerant scenario. Should one of the replicas fail, the objects are replicated in another server in order to maintain a certain level of availability in the system.
\end{enumerate}

Upon {\it attempting a transaction} the following communication exists between the Client, Master and Object Servers in a {\bf fault-tolerant} environment: 
\begin{enumerate}
\item Client connects to the Master and requests a transaction identifier 
\item Master maintains a global transaction sequence and returns a unique transaction identifier (TID) to the Client. Furthermore, a list of healthy Object Servers is also returned to the Client. 
\item Client generates a unique ID (integer) when generating the object and also be used in order to select an available server from the list (used in a modulo function)
\item Client uses the modulo result to connect to the Object Server and store the object representing the tentative versions of the transaction.
\end{enumerate}

The main difference between the above steps and the communication in a {\bf perfect} environment is that the TID is not necessarily assigned by the Master, but any of the Servers.

When the Client attempts to {\bf manipulate an existing object} in the {\it perfect} environment, the following communication takes place:
\begin{enumerate}
\item Client requests and retrieves TID from Master
\item Client retrieves object's previously generated unique ID
\item Client applies modulo on the retrieved ID to locate the relevant Object Server to request for reference
\item With the retrieved object reference, client can manipulate the object value
\end{enumerate}

%------------------------------------------------------------------------- 
\SubSection{Transaction Management and Concurrency Control}
\label{subsec:transmgt}
The {\it Flat Transaction} model allows for a client to manipulate objects on multiple servers in a single transaction. With regards to concurrency control, {\it Timestamp Ordering} will be used for this project. Figure \ref{fig:flat} illustrates a flat transaction model setup with a transaction being executed from the client on 3 servers.

\begin{figure}
\centering
\includegraphics[scale=0.2]{flat-transaction.eps}
\caption{Flat Transaction model between a Client and 3 Servers}
\label{fig:flat}
\end{figure}


The advantages of choosing {\it Timestamp Ordering} over {\it Two-Phase Locking} or {\it Optimistic Concurrency} options are the following: 
\begin{itemize}[noitemsep, nolistsep]
\item Deadlock prevention - common with the use of locks
\item Better performance for transactions with predominantly {\it read} operations \cite{bernstein1987concurrency}
\item Faster conflict resolution when compared to locking - transactions are aborted immediately.
\end{itemize}

Figure \ref{fig:transa} illustrates the steps between the Client, Coordinator, Master and Object Serves during a transaction. The steps below further details the communication that occurs between processes in a perfect setup: 

\begin{enumerate}[noitemsep, nolistsep]
\item {\bf Steps 3-4:} Client acquires transaction ID from the Coordinator 
\item {\bf Step 5:} Client passes TID to the Object Server
\item {\bf Step 6:} Object Server calls the Coordinator's {\it inteface}
\item {\bf Steps 7-8:} Client manipulates objects directly on the Object Server
\item {\bf Step 9:} Upon transaction end, Client asks the Coordinator to either {\it Abort} or {\it Commit} 
\item {\bf Step 10:} Coordinator will request each participant server in the transaction to indicate whether it can commit a transaction or not.{\it (Voting Phase)}
\item {\bf Step 12:} If all participants answer/vote {\it positively}, the Coordinator issues {\bf doCommit(TID)} and each parcipant commits its part of the transaction
\item {\bf Step 13:} Once completed, all servers acknowledge the commit and Coordinator notifies the Client that it's successful.
\item Should any of the participant servers be unable or disagree to commit and aborts, the Coordinator will request all the remaining participants to abort. Client will then be notified.
\end{enumerate}

\begin{figure}
\centering
\includegraphics[scale=0.2]{transaction.eps}
\caption{Transaction steps between the Client, Master, Coordinator and Servers}
\label{fig:transa}
\end{figure}



%-------------------------------------------------------------------------
\SubSection{Timestamp Ordering and Deadlock Detection}
\label{subsec:dldetect}
Since timestamp ordering will be used for concurrency control the chances of deadlock occurring are limited.
Each transaction is assigned a unique timestamp upon start. Each operation in a transaction is validated when it is carried out.
Should a transaction fail the validation, it is aborted immediately, but can be restarted by the client. The client is issued with a globally unique transaction timestamp by the Coordinator. The servers are jointly responsible for ensuring serial equivalence i.e. if server S1 access an object before S2, then server S1 is before S2 at all objects. The coordinators must agree on timestamp ordering so as to achieve the same ordering at all the servers. The timestamp will consist of a {\it <local timestamp, server-id> } pair. Timestamps can be kept roughly synchronized by the use of synchronized local physical clocks coordinated by the master.

Conflict resolution will be performed at each operation.
The basic timestamp ordering rule is based on operation conflicts and is very simple:
{\it A transaction’s request to write an object is valid only if that object was last read and written by earlier transactions. A transaction’s request to read an object is valid only if that object was last written by an earlier transaction.} [Reference: Distributed Systems].
If the resolution is to abort the transaction then the coordinator will be informed and it will abort the transaction at all the participants.

%--------------------------------------------------------------------------
\SubSection{Fault Tolerant scenario}
\label{subsec:faultol}
In this phase we design to provide fault tolerance for single object server failure. This is an extension for the previous design. The idea is to keep an exact copy of the objects in adjacent server.
For instance the object stored in Object server S1, should keep the exact copy in the S2 server as a replica. The master server is responsible for keeping track of the replica servers.

When the object server {\bf fails},
\begin{enumerate}[noitemsep, nolistsep]
\item Master detects the server failure from the absence of the heartbeat message from the object server.
\item Master server issues a {\it “failure warning notification”} for the servers, so that the current transactions related to the absent server will be aborted.
Others will continue but new transactions will not be proceeded. (Master block providing TIDs)
\item Master server coordinates object replication so that the currently available servers share the objects held by the absent server.
\item Once the master notifies all the servers about the stabilized status, transactions can be continued again.
\end{enumerate}

When the failed server {\bf recovers},
\begin{enumerate}[noitemsep, nolistsep]
\item Master detects the arrival of a new server.
\item Master server issues a {\it “New server notification”} for the servers. Once the current pending transactions are completed, stabilizing the servers occur.
\item Master server coordinates object replication so that the currently available servers share the objects held by the absent server.
\item Once the master notifies all the servers the stabilized status, transactions can be continued again.
\end{enumerate}

%------------------------------------------------------------------------- 
\Section{Footnotes}

Please use footnotes sparingly%
\footnote
   {%
     Or, better still, try to avoid footnotes altogether.  To help your 
     readers, avoid using footnotes altogether and include necessary 
     peripheral observations in the text (within parentheses, if you 
     prefer, as in this sentence).
   }
and place them at the bottom of the column on the page on which they are 
referenced. Use Times 8-point type, single-spaced.


%------------------------------------------------------------------------- 
\SubSection{References}

%------------------------------------------------------------------------- 
\SubSection{Conclusions}

%------------------------------------------------------------------------- 
\bibliographystyle{latex8}
\bibliography{latex8}

\end{document}

