
%
%  $Description: Author guidelines and sample document in LaTeX 2.09$ 
%
%  $Author: ienne $
%  $Date: 1995/09/15 15:20:59 $
%  $Revision: 1.4 $
%

\documentclass[times, 10pt,twocolumn]{article} 
\usepackage{latex8}
\usepackage{times}
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage{enumitem}

%\documentstyle[times,art10,twocolumn,latex8]{article}

%------------------------------------------------------------------------- 
% take the % away on next line to produce the final camera-ready version 
\pagestyle{empty}

%------------------------------------------------------------------------- 
\begin{document}

\title{Distributed Software Transactional Memory}

\maketitle
\thispagestyle{empty}

\begin{abstract}


   The present paper describes the details of a distributed software
   transactional memory implementation.
   There are 2 scenarios presented for a Master/Server architecture: \\
   a) perfect links and processes (Master and Servers) \\
   b) perfect links and Master, but recoverable Servers \\

   Transaction management, concurrency control, failure detector and 
   replication mechanisms are described for both perfect and fault-tolerant
   architectures.
   
\end{abstract}



%------------------------------------------------------------------------- 
\Section{Introduction}
In the following sections the implementation of a distributed software 
transactional memory library is presented for two scenarios:\\
a) perfect Master, Servers and links\\
b) perfect Master, links and recoverable, sequentially consistent Servers\\

Section \ref{sec:arch} introduces an overview of each scenario. Section 
\ref{sec:algor} discusses the algorithms used for concurrency control, 
transaction management and Client-Server communication


%------------------------------------------------------------------------- 
\Section{Architecture}
\label{sec:arch}

The assumption made for all the sections below is that the Master is a perfect process. The names Object Servers and Servers are used interchangeably across the sections below and refer to the any non-Master process participant in a transaction.

Main differences between the two architectures, perfect and fault-tolerant, are the following:
\begin{itemize}[noitemsep,nolistsep]
\item for perfect, the Coordinator can be any server, not necessarily the Master
\item 
\end{itemize}
%TODO: Add more differences between the two archs.

%------------------------------------------------------------------------- 
\SubSection{Perfect links and processes}
\label{subsec:perf}
As illustrated in Figure \ref{fig:perf}, the architecture consists of the 
following perfect entities: 
\begin{itemize}[noitemsep,nolistsep]
\item {\bf M} - Master server 
\item {\bf S} - Object server
\item {\bf C} - Client      
\end{itemize}

\begin{figure}
\centering
\includegraphics[scale=0.3]{perfect.eps}
\caption{Master/Server entities in a perfect setup}
\label{fig:perf}
\end{figure}
Note that the number of object servers can be varied.
%------------------------------------------------------------------------- 
\SubSection{Recoverable, replicated Servers with perfect Master}
\label{subsec:recov}

%------------------------------------------------------------------------- 
\SubSection{Coordinator/Master responsiblities}
\label{subsec:respon}

The Coordinator's responsabilities and interface is different for the two scenarios (perfect and fault-tolerant) detailed in Section \ref{sec:arch}. For instance, assuming perfect links and processes, the Coordinator can be any of the Servers, thus reducing the Master's load. The list of servers the Client chooses from is supplied by the Master to the Client and it's updated with every Server group membership change.

%------------------------------------------------------------------------- 
\Section{Algorithms}
\label{sec:algor}
In the subsections below, the steps for the most important parts of the system are enlisted.

%------------------------------------------------------------------------ 
\SubSection{Communication}
The following communication occurs {\bf before} the client attempts connection to the Master node - it is the communication exchanged between the Master and the Servers.
\begin{enumerate}
\item Master boots first followed by the Object Servers bootstrap
\item During Object Servers bootstrap:
\begin{enumerate}
\item Master identifies the Object Servers trying to connect
\item Master assigns a unique name to the Object Servers to be later used as a reference
\end{enumerate}
\item Object Servers's heartbeat messages periodically sent to Master. This is useful for replica management i.e. If one of the replicas fail then the objects can be replicated in another replica to always maintain a certain level of availability in the system.
\end{enumerate}

Upon {\bf attempting a transaction} (object storage) the following communication exists between the Client and Master and Object Servers: 
\begin{enumerate}
\item Client connects to the Master and requests a transaction identifier 
\item Master maintains a global transaction sequence and returns a unique transaction identifier (TID) to the Client. Furthermore, a list of healthy Object Servers is also returned to the Client. 
\item Client generates a unique ID (integer) when generating the object and also be used in order to select an available server from the list (used in a modulo function)
\item Client uses the modulo result to connect to the Object Server and store the object representing the tentative versions of the transaction.
\end{enumerate}

When the Client attempts to {\bf manipulate an existing object} in the {\it perfect} Object Servers, the following communication takes place:
\begin{enumerate}
\item Client requests and retrieves TID from Master
\item Client retrieves object's previously generated unique ID
\item Client applies modulo on the retrieved ID to locate the relevant Object Server to request for reference
\item With the retrieved object reference, client can manipulate the object value
\end{enumerate}

%------------------------------------------------------------------------- 
\SubSection{Transaction Management and Concurrency Control}
\label{subsec:transmgt}
The {\it Flat Transaction} model allows for a client to manipulate objects on multiple servers in a single transaction. With regards to concurrency control {\it Timestamp Ordering} is being chosen. Figure \ref{fig:flat} illustrates a flat transaction model setup with a {\it transaction} being executed from the client on 3 servers.

\begin{figure}
\centering
\includegraphics[scale=0.2]{flat-transaction.eps}
\caption{Flat Transaction model between a Client and 3 Servers}
\label{fig:flat}
\end{figure}


The advantages of choosing {\it Timestamp Ordering} over {\it Two-Phase Locking} or {\it Optimistic Concurrency} options are the following: 
\begin{itemize}[noitemsep,nolistsep]
\item Deadlock prevention - common with the use of locks
\item Better performance for transactions with predominantly {\it read} operations \cite{bernstein1987concurrency}
\item Faster conflict resolution when compared to locking - transactions are aborted immediately.
\end{itemize}

The following steps are made when performing a transaction in the {\bf perfect} environment - assuming no link or process failures: 
\begin{enumerate}
\item Client acquires transaction ID from the Master
\item Client passes TID to the Object Server
\item Object Server calls the Coordinator's(Master's) {\it join()} method along with TID as parameter
\item Client manipulates objects directly on the Object Server
\item Upon transaction end, Client asks the Coordinator to either {\it Abort} or {\it Commit} 
\item Coordinator will request each participant server in the transaction to indicate whether it can commit a transaction or not.
\item If all participants answer {\it yes}, Coordinator issues {\bf doCommit(TID)} command such that each parcipant commits its part of the transaction
\item Once completed, all servers acknowledge the commit and Coordinator notifies the Client that it's successful.
\item Should any of the participant servers be unable or disagree to commit and aborts, the Coordinator will request all the remaining participants to abort. Client will then be notified.
\end{enumerate}

%-------------------------------------------------------------------------
\SubSection{Timestamp Ordering and Deadlock Detection}
\label{subsec:dldetect}
Since timestamp ordering will be used for concurrency control the chances of deadlock occurring are limited.
Each transaction is assigned a unique timestamp upon start. Each operation in a transaction is validated when it is carried out.
Should a transaction fail the validation, it is aborted immediately, but can be restarted by the client. The client is issued with a globally unique transaction timestamp by the Coordinator. The servers are jointly responsible for ensuring serial equivalence i.e. if server S1 access an object before server S2, then server S1 is before S2 at all objects. The coordinators must agree on timestamp ordering so as to achieve the same ordering at all the servers. The timestamp will consist of a {\it <local timestamp, server-id> } pair. Timestamps can be kept roughly synchronized by the use of synchronized local physical clocks coordinated by the master.

Conflict resolution will be performed at each operation.
The basic timestamp ordering rule is based on operation conflicts and is very simple:
{\it A transaction’s request to write an object is valid only if that object was last read and written by earlier transactions. A transaction’s request to read an object is valid only if that object was last written by an earlier transaction.} [Reference: Distributed Systems].
If the resolution is to abort the transaction then the coordinator will be informed and it will abort the transaction at all the participants.

%--------------------------------------------------------------------------
\SubSection{Fault Tolerant environment}
\label{subsec:faultol}
In this phase we design to provide fault tolerance for single object server failure. This is an extension for the previous design. The idea is to keep an exact copy of the objects in adjacent server.
For instance the object stored in Object server S1, should keep the exact copy in the S2 server as a replica. The master server is responsible for keeping track of the replica servers.

When the object server {\bf fails},
\begin{enumerate}
\item Master detects the server failure from the absence of the heartbeat message from the object server.
\item Master server issues a {\it “failure warning notification”} for the servers, so that the current transactions related to the absent server will be aborted.
Others will continue but new transactions will not be proceeded. (Master block providing TIDs)
\item Master server coordinates object replication so that the currently available servers share the objects held by the absent server.
\item Once the master notifies all the servers about the stabilized status, transactions can be continued again.
\end{enumerate}

When the failed server {\bf recovers},
\begin{enumerate}
\item Master detects the arrival of a new server.
\item Master server issues a {\it “New server notification”} for the servers. Once the current pending transactions are completed, stabilizing the servers occur.
\item Master server coordinates object replication so that the currently available servers share the objects held by the absent server.
\item Once the master notifies all the servers the stabilized status, transactions can be continued again.
\end{enumerate}

%------------------------------------------------------------------------- 
\Section{Footnotes}

Please use footnotes sparingly%
\footnote
   {%
     Or, better still, try to avoid footnotes altogether.  To help your 
     readers, avoid using footnotes altogether and include necessary 
     peripheral observations in the text (within parentheses, if you 
     prefer, as in this sentence).
   }
and place them at the bottom of the column on the page on which they are 
referenced. Use Times 8-point type, single-spaced.


%------------------------------------------------------------------------- 
\SubSection{References}

%------------------------------------------------------------------------- 
\SubSection{Conclusions}

%------------------------------------------------------------------------- 
\bibliographystyle{latex8}
\bibliography{latex8}

\end{document}

